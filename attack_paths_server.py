from typing import Dict, Any, List, Optional
import os
import datetime
import uuid
import argparse
from fastmcp import FastMCP
from attack_paths_utils import RaptorAPIClient, SignalRAttackPathClient, SIGNALR_AVAILABLE


class AttackPathsMCPServer:
    """MCP server for Attack Path Analysis operations using SignalR."""
    
    def __init__(self, raptor_token: Optional[str] = None, raptor_url: Optional[str] = None, hub_path: Optional[str] = None):
        self.mcp = FastMCP(
            name="Attack Paths Analysis Server",
            instructions="""
            This server provides detailed attack path analysis through the Raptor SignalR API.
            
            The server connects to a SignalR hub to stream real-time attack path summaries
            generated by LLM analysis of complex attack path data.
            """
        )
        
        # Configure connections
        self._raptor_token = raptor_token or os.getenv("RAPTOR_TOKEN")
        self._raptor_url = raptor_url or "http://localhost:5000"
        self._hub_path = hub_path or "/api"
        
        # Convert HTTP URL to WebSocket URL for SignalR
        ws_url = self._raptor_url.replace("http://", "ws://").replace("https://", "wss://")
        self._hub_url = f"{ws_url}{self._hub_path}"
        
        self._api_client = RaptorAPIClient(f"{self._raptor_url}/v1", self._raptor_token)
        self._signalr_client = None
        self._register_tools()
    
    async def _get_signalr_client(self) -> SignalRAttackPathClient:
        """Get or create SignalR client connection."""
        if not self._signalr_client:
            self._signalr_client = SignalRAttackPathClient(self._hub_url, self._raptor_token)
            
        if not self._signalr_client.is_connected:
            connected = await self._signalr_client.connect()
            if not connected:
                raise ConnectionError("Failed to connect to SignalR hub")
                
        return self._signalr_client
    
    def _register_tools(self) -> None:
        """Register all MCP tools."""
        
        @self.mcp.tool()
        async def detailed_attack_path_analysis(
            source_oid: str,
            target_oid: str,
            attack_path_id: Optional[str | int] = None
        ) -> Dict[str, Any]:
            """
            Performs comprehensive and structured AI-powered analysis of attack paths between source and target objects.
            
            **Parameters**:
            - source_oid (required): Object identifier of the attack source
            - target_oid (required): Object identifier of the attack target
            - attack_path_id (optional): Specific attack path ID when multiple paths exist
            
            **Behavior**:
            • Single path found: Automatically generates structured AI analysis
            • Multiple paths found: Returns raw attack path data with selection prompt
            • Specific path requested: Analyzes the selected attack path by ID
            • No paths found: Returns descriptive error
            
            **Analysis Output Format**:
            The AI analysis provides structured JSON containing:
            - Objects: Detailed descriptions of entities in the attack path
            - Relationships: Security-relevant connections and permissions
            - KeyPointsOfConcern: Critical security issues and risks identified
            - Conclusion: Executive summary with remediation recommendations
            
            **Response Types**:
            - attack_path_analysis: Complete structured analysis (JSON string)
            - attack_paths_response: Raw API response with all available paths
            - message: User guidance for path selection
            - error: Detailed error description with available options
            """
            
            if not SIGNALR_AVAILABLE:
                return {"error": "SignalR functionality not available. Please install signalrcore: pip install signalrcore"}
            
            # Validate required parameters
            if not source_oid or not target_oid:
                return {"error": "Both source_oid and target_oid are required"}
            
            try:
                # Step 1: Get attack path data
                attack_path_params = self._build_attack_path_params(source_oid, target_oid)
                attack_paths_response = self._api_client.call("DetermineAttackPaths", attack_path_params)
                
                if "error" in attack_paths_response:
                    return {"error": f"Failed to determine attack paths: {attack_paths_response['error']}"}
                
                # Extract attack paths
                response_data = attack_paths_response.get("response", {})
                attack_paths = response_data.get("AttackPaths", [])
                
                # Handle no paths found
                if len(attack_paths) == 0:
                    return {"error": f"No attack path found between '{source_oid}' and '{target_oid}'"}
                
                # Handle single path - analyze automatically
                elif len(attack_paths) == 1:
                    target_attack_path = attack_paths[0]
                    return await self._analyze_attack_path(target_attack_path)
                
                # Handle multiple paths
                else:
                    # If specific attack_path_id provided, find and analyze it
                    if attack_path_id is not None:
                        target_attack_path = None
                        # Convert attack_path_id to string for comparison if it's an integer
                        search_id = str(attack_path_id)
                        
                        for path in attack_paths:
                            path_id = str(path.get("Id", ""))
                            if path_id == search_id:
                                target_attack_path = path
                                break
                        
                        if not target_attack_path:
                            available_ids = [path.get("Id") for path in attack_paths]
                            return {"error": f"Attack path ID '{attack_path_id}' not found. Available IDs: {available_ids}"}
                        
                        return await self._analyze_attack_path(target_attack_path)
                    
                    # Multiple paths found, no specific ID - return for selection
                    else:
                        return {
                            "attack_paths_response": attack_paths_response,
                            "message": f"Multiple attack paths found ({len(attack_paths)} paths). Please select a specific attack path ID and rerun the tool with the attack_path_id parameter."
                        }
                
            except Exception as e:
                return {"error": f"Failed to complete attack path analysis: {str(e)}"}
    
    def _process_streaming_results(self, streaming_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Process the streaming results from SignalR into a structured summary."""
        if not streaming_results:
            return {"content": "No summary content received", "finish_reason": "no_content", "total_chunks": 0}
        
        full_content = ""
        finish_reason = "completed"
        
        for result in streaming_results:
            content = result.get("Content", "")
            if content:
                full_content += content
            
            if result.get("FinishReason"):
                finish_reason = result.get("FinishReason")
        
        if full_content and finish_reason == "completed":
            finish_reason = "stop"
        
        return {
            "content": full_content,
            "finish_reason": finish_reason,
            "total_chunks": len(streaming_results)
        }
    
    async def _analyze_attack_path(self, target_attack_path: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze a specific attack path using SignalR streaming."""
        summary_id = str(uuid.uuid4())
        
        summary_parameters = {
            "SummaryId": summary_id,
            "SummaryAttackPath": target_attack_path,
            "ForceRefresh": False
        }
        
        # Get SignalR streaming summary
        signalr_client = await self._get_signalr_client()
        streaming_results = await signalr_client.get_attack_path_summary(summary_parameters)
        
        # Process results
        summary_content = self._process_streaming_results(streaming_results)
        
        return {"attack_path_analysis": summary_content["content"]}
    
    def _build_attack_path_params(self, source_oid: str, target_oid: str) -> Dict[str, Any]:
        """Build parameters for attack path-related API calls."""
        return {
            "ZeroCostPaths": False,
            "IncludeBlowoutPaths": True,
            "ReturnPrincipalsOnly": True,
            "ZeroCostOnly": False,
            "BlowoutPaths": 250,
            "AttackerID": source_oid,
            "TargetID": target_oid
        }
    
    def run(self, transport: str = 'streamable-http', host: str = '127.0.0.1', port: int = 8001, path: str = '/mcp') -> None:
        """Run the MCP server with HTTP transport."""
        self.mcp.run(transport=transport, host=host, port=port, path=path)


# Singleton instance for backward compatibility
_server_instance = None

def get_server_instance() -> AttackPathsMCPServer:
    """Get or create the singleton server instance."""
    global _server_instance
    if _server_instance is None:
        _server_instance = AttackPathsMCPServer()
    return _server_instance


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Attack Paths MCP Server (SignalR)")
    parser.add_argument("-raptor_token", type=str, default=None, help="Override RAPTOR_TOKEN for API access")
    parser.add_argument("-raptor_url", type=str, default="http://localhost:5000", help="Override RAPTOR_URL for SignalR hub access")
    parser.add_argument("-host", type=str, default="127.0.0.1", help="Host to bind the server to (default: 127.0.0.1)")
    parser.add_argument("-port", type=int, default=8003, help="Port to bind the server to (default: 8003)")
    parser.add_argument("-path", type=str, default="/mcp", help="URL path for the MCP endpoint (default: /mcp)")
    args = parser.parse_args()

    server = AttackPathsMCPServer(raptor_token=args.raptor_token, raptor_url=args.raptor_url)
    server.run(transport='streamable-http', host=args.host, port=args.port, path=args.path)
