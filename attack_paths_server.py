from typing import Dict, Any, List, Optional
import os
import datetime
import uuid
import argparse
from fastmcp import FastMCP
from attack_paths_utils import RaptorAPIClient, SignalRAttackPathClient, SIGNALR_AVAILABLE


class AttackPathsMCPServer:
    """MCP server for Attack Path Analysis operations using SignalR."""
    
    def __init__(self, raptor_token: Optional[str] = None, raptor_url: Optional[str] = None, hub_path: Optional[str] = None):
        self.mcp = FastMCP(
            name="Attack Paths Analysis Server",
            instructions="""
            This server provides detailed attack path analysis through the Raptor SignalR API.
            
            The server connects to a SignalR hub to stream real-time attack path summaries
            generated by LLM analysis of complex attack path data.
            """
        )
        
        # Configure connections
        self._raptor_token = raptor_token or os.getenv("RAPTOR_TOKEN")
        self._raptor_url = raptor_url or "http://localhost:5000"
        self._hub_path = hub_path or "/api"
        
        # Convert HTTP URL to WebSocket URL for SignalR
        ws_url = self._raptor_url.replace("http://", "ws://").replace("https://", "wss://")
        self._hub_url = f"{ws_url}{self._hub_path}"
        
        self._api_client = RaptorAPIClient(f"{self._raptor_url}/v1", self._raptor_token)
        self._signalr_client = None
        self._register_tools()
    
    async def _get_signalr_client(self) -> SignalRAttackPathClient:
        """Get or create SignalR client connection."""
        if not self._signalr_client:
            self._signalr_client = SignalRAttackPathClient(self._hub_url, self._raptor_token)
            
        if not self._signalr_client.is_connected:
            connected = await self._signalr_client.connect()
            if not connected:
                raise ConnectionError("Failed to connect to SignalR hub")
                
        return self._signalr_client
    
    def _register_tools(self) -> None:
        """Register all MCP tools."""
        
        @self.mcp.tool()
        async def detailed_attack_path_analysis(
            attacker_oid: str,
            target_oid: str,
            domain_filter: Optional[List[str]] = None,
            zone_filter: Optional[List[str]] = None,
            zero_cost_only: bool = False,
            summary_id: Optional[str] = None,
            force_refresh: bool = False
        ) -> Dict[str, Any]:
            """
            **Role**: AI-Powered, detailed and structured analysis of a specific attack path
            
            This tool requires specific attacker and target OIDs to identify a single attack path.
            In most cases, these two OIDs should be sufficient to uniquely identify one path.
            If multiple paths exist, optional filters can be used to narrow down the search.
            
            **Inputs**:
            - attacker_oid: REQUIRED. Object identifier of the attack source.
            - target_oid: REQUIRED. Object identifier of the attack target.
            - domain_filter: Optional list of domain names to narrow the search if multiple paths exist.
            - zone_filter: Optional list of security zone IDs to narrow the search if multiple paths exist.
            - zero_cost_only: Optional flag to focus only on zero-cost (immediate) attack paths. Default False.
            - summary_id: Optional unique identifier for the summary request.
            - force_refresh: Optional flag to force a refresh of the summary even if cached. Default False.
            
            **Outputs**:
            - attack_paths_response: The full response from determine_attack_paths call
            - target_attack_path: The specific attack path that was analyzed
            - streaming_summary: Complete LLM-generated summary content
            - summary_metadata: Analysis metadata including timing and message count
            - attack_path_info: Extracted information about the attack path
            - analysis_completed: Boolean indicating successful completion
            
            **Error Conditions**:
            - Returns error if attacker_oid or target_oid are not provided
            - Returns error if no attack path exists between the specified nodes
            - Returns error if multiple attack paths exist (suggests using filters to narrow down)
            """
            
            if not SIGNALR_AVAILABLE:
                return {"error": "SignalR functionality not available. Please install signalrcore: pip install signalrcore"}
            
            # Validate required parameters
            if not attacker_oid or not target_oid:
                return {"error": "Both attacker_oid and target_oid are required to identify a specific attack path"}
            
            try:
                # Step 1: Get attack path data
                attack_path_params = self._build_attack_path_params(
                    domain_filter, zone_filter, zero_cost_only, attacker_oid, target_oid
                )
                
                attack_paths_response = self._api_client.call("DetermineAttackPaths", attack_path_params)
                
                if "error" in attack_paths_response:
                    return {"error": f"Failed to determine attack paths: {attack_paths_response['error']}"}
                
                # Extract and validate attack paths
                response_data = attack_paths_response.get("response", {})
                attack_paths = response_data.get("ZeroCostAttackPaths" if zero_cost_only else "AttackPaths", [])
                
                if len(attack_paths) == 0:
                    return {"error": f"No attack path found between '{attacker_oid}' and '{target_oid}'"}
                elif len(attack_paths) > 1:
                    return {"error": f"Multiple attack paths found ({len(attack_paths)} paths). Use domain_filter or zone_filter to narrow down to exactly one path"}
                
                # Step 2: Analyze the single attack path
                target_attack_path = attack_paths[0]
                summary_id = summary_id or str(uuid.uuid4())
                
                summary_parameters = {
                    "SummaryId": summary_id,
                    "SummaryAttackPath": target_attack_path,
                    "ForceRefresh": force_refresh
                }
                
                # Step 3: Get SignalR streaming summary
                signalr_client = await self._get_signalr_client()
                streaming_results = await signalr_client.get_attack_path_summary(summary_parameters)
                
                # Process results
                summary_content = self._process_streaming_results(streaming_results)
                
                return {"attack_path_analysis": summary_content["content"]}
                
            except Exception as e:
                return {"error": f"Failed to complete attack path analysis: {str(e)}"}
    
    def _process_streaming_results(self, streaming_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Process the streaming results from SignalR into a structured summary."""
        if not streaming_results:
            return {"content": "No summary content received", "finish_reason": "no_content", "total_chunks": 0}
        
        full_content = ""
        finish_reason = "completed"
        
        for result in streaming_results:
            content = result.get("Content", "")
            if content:
                full_content += content
            
            if result.get("FinishReason"):
                finish_reason = result.get("FinishReason")
        
        if full_content and finish_reason == "completed":
            finish_reason = "stop"
        
        return {
            "content": full_content,
            "finish_reason": finish_reason,
            "total_chunks": len(streaming_results)
        }
    
    def _build_attack_path_params(self, domain_filter: Optional[List[str]], 
                                 zone_filter: Optional[List[str]], 
                                 zero_cost_only: bool,
                                 attacker_oid: str,
                                 target_oid: str) -> Dict[str, Any]:
        """Build parameters for attack path-related API calls."""
        params = {
            "ZeroCostPaths": False,
            "IncludeBlowoutPaths": True,
            "ReturnPrincipalsOnly": True,
            "ZeroCostOnly": zero_cost_only,
            "BlowoutPaths": 250,
            "AttackerID": attacker_oid,
            "TargetID": target_oid
        }
        
        if domain_filter is not None:
            params["DomainFilter"] = domain_filter
        if zone_filter is not None:
            params["ZoneFilter"] = zone_filter
            
        return params
    
    def run(self, transport: str = 'streamable-http', host: str = '127.0.0.1', port: int = 8001, path: str = '/mcp') -> None:
        """Run the MCP server with HTTP transport."""
        self.mcp.run(transport=transport, host=host, port=port, path=path)


# Singleton instance for backward compatibility
_server_instance = None

def get_server_instance() -> AttackPathsMCPServer:
    """Get or create the singleton server instance."""
    global _server_instance
    if _server_instance is None:
        _server_instance = AttackPathsMCPServer()
    return _server_instance


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Attack Paths MCP Server (SignalR)")
    parser.add_argument("-raptor_token", type=str, default=None, help="Override RAPTOR_TOKEN for API access")
    parser.add_argument("-raptor_url", type=str, default="http://localhost:5000", help="Override RAPTOR_URL for SignalR hub access")
    parser.add_argument("-host", type=str, default="127.0.0.1", help="Host to bind the server to (default: 127.0.0.1)")
    parser.add_argument("-port", type=int, default=8003, help="Port to bind the server to (default: 8003)")
    parser.add_argument("-path", type=str, default="/mcp", help="URL path for the MCP endpoint (default: /mcp)")
    args = parser.parse_args()

    server = AttackPathsMCPServer(raptor_token=args.raptor_token, raptor_url=args.raptor_url)
    server.run(transport='streamable-http', host=args.host, port=args.port, path=args.path)
